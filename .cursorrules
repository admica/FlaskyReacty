# PCAP Server

Every time you choose to apply a rule(s), explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase.

## Project Context

The PCAP Server is a distributed network packet capture management platform that coordinates with remote sensors to execute packet capture requests and analyze network data.

Key Features:
- Job Management System
  - Hierarchical job/task structure
  - Location-based sensor targeting
  - Automated task distribution
  - Intelligent job status tracking
- Sensor Integration
  - Metadata collection of /24 subnet visibility
  - Remote PCAP file retrieval
  - Distributed capture coordination
- Data Processing
  - Automated PCAP merging
  - Task result aggregation
  - Status tracking and reporting
- Web Interface
  - Job creation and monitoring
  - Real-time status updates
  - Result visualization
  - User access control

Target Users:

- Network forensics investigators
- Security analysts
- Network administrators
- DevOps engineers

## Code Style and Structure

Frontend:
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure repository files as follows:

Backend:
- Use Flask Blueprints for API organization
- Implement proper request validation with type hints
- Use raw SQL with parameterized queries (no ORM)
- Follow a modular database initialization approach (numbered SQL files)
- Implement proper error handling and logging
- Use configuration files for environment settings
- Implement proper cleanup handlers for graceful shutdown
- Use Redis for caching and token management
- Implement proper subprocess and thread management for background tasks
- Use type hints for function parameters and returns
- Keep endpoint handlers focused on:
  - Request validation
  - Parameter processing
  - Error handling
  - Response formatting
- Follow RESTful API patterns for endpoints
- Use JWT for authentication with proper token management

```
pcapserver/
├── api/               # Backend API endpoints
│   ├── auth.py        # Authentication
│   ├── jobs.py        # Job management
│   ├── sensors.py     # Sensor management
│   ├── preferences.py # User preferences
│   ├── health.py      # Health checks
│   ├── search.py      # Search functionality
│   ├── network.py     # Network operations
│   └── admin.py       # Admin operations
├── frontend/
│   └── src/
│       ├── components/       # Shared React components
│       │   ├── dashboard/
│       │   ├── network/
│       │   ├── jobs/
│       │   ├── preferences/
│       │   ├── admin/
│       │   ├── auth/
│       │   ├── layout/
│       │   ├── sensors/
│       │   └── ui/
│       ├── services/
│       ├── routes/
│       ├── lib/
│       └── api/
├── tests/                  # Testing framework
│   ├── base.py             # Base test functionality
│   ├── test_login.py       # Auth tests
│   ├── test_preferences.py # Preferences tests
│   └── *.py                # Additional tests
```

## Tech Stack

### Backend
- Python 3.11+
- Flask 3.1 with blueprints
- Redis 5 (for token mgmt and caching)
- JWT for authentication
- PostgreSQL 16 with raw SQL (no ORM)
- Protected routes and session mgmt
- No FastAPI

### Frontend
- React 18.2
- TypeScript 5.2
- Vite 5.0
- Mantine 7.3 (core UI components)
- Radix UI (low-level components)
- Tailwind CSS
- React Router 6.20
- Three.js and react-globe.gl (for network visualization)
- Axios for API calls
- No Redux

### Architecture
- Distributed system with remote sensors
- Job/task management system
- Network visualization
- Real-time monitoring
- Role-based access control

## Naming Conventions
- Use lowercase with underscores for directories (e.g., components/form-wizard)
- Favor named exports for components and utilities
- Use PascalCase for component files (e.g., VisaForm.tsx)
- Use camelCase for utility files (e.g., formValidator.ts)

## TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use const objects with 'as const' assertion
- Use functional components with TypeScript interfaces
- Define strict types for message passing between different parts of the extension
- Use absolute imports for all files @/...
- Avoid try/catch blocks unless there's good reason to translate or handle error in that abstraction
- Use explicit return types for all functions

## Syntax and Formatting
- Use declarative JSX
- Implement proper TypeScript discriminated unions for message types

## UI and Styling
- Use Shadcn UI and Mantine for components
- use `npx shadcn@latest add <component-name>` to add new shadcn components
- Implement Tailwind CSS for styling
- Consider extension-specific constraints (popup dimensions, permissions)
- When adding new shadcn component, document the installation command

## Error Handling
- Implement proper error boundaries
- Log errors appropriately for debugging
- Provide user-friendly error messages
- Handle network failures gracefully

## Testing
- Write unit tests for utilities and components
- Implement E2E tests for critical flows

## Security
- Implement Content Security Policy
- Sanitize user inputs
- Handle sensitive data properly

## Git Usage
Commit Message Prefixes:
- "fix:" for bug fixes
- "feat:" for new features
- "perf:" for performance improvements
- "docs:" for documentation changes
- "style:" for formatting changes
- "refactor:" for code refactoring
- "test:" for adding missing tests
- "chore:" for maintenance tasks

Rules:
- Use lowercase for commit messages
- Keep the summary line concise
- Include description for non-obvious changes
- Reference issue numbers when applicable

## Documentation
- Maintain clear README with setup instructions
- Document API interactions and data flows
- Keep manifest.json well-documented
- Don't include comments unless it's for complex logic
- Document permission requirements

## Development Workflow
- Use proper version control
- Implement proper code review process
- Test in multiple environments
- Follow semantic versioning for releases
- Maintain changelog
